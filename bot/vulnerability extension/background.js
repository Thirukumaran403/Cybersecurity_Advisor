// chrome.runtime.onInstalled.addListener(() => {
//     console.log("Website Vulnerability Checker Extension is installed.");
//   });
  
//   async function checkWebsite(url) {
//     try {
//       const response = await fetch(url);
//       const text = await response.text();
  
//       // A simple vulnerability check example
//       let vulnerabilities = [];
  
//       // Check for missing headers (simulating security header check)
//       const headers = response.headers;
//       if (!headers.get('X-Frame-Options')) {
//         vulnerabilities.push("Missing X-Frame-Options header.");
//       }
  
//       // Check for open directories (for simplicity, just using a few common paths)
//       const commonDirs = ['/admin/', '/backup/', '/test/'];
//       for (let dir of commonDirs) {
//         if (text.includes(dir)) {
//           vulnerabilities.push(`Open directory found: ${dir}`);
//         }
//       }
  
//       return vulnerabilities;
//     } catch (error) {
//       console.error("Error checking website:", error);
//       return ["Error: Unable to check website."];
//     }
//   }
  
//   // Listen for messages from content.js to start the check
//   chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
//     if (message.action === 'check_website') {
//       checkWebsite(message.url).then(vulnerabilities => {
//         sendResponse(vulnerabilities);
//       });
//       return true;  // Keeps the message channel open for async response
//     }
//   });
chrome.runtime.onInstalled.addListener(() => {
    console.log("Website Vulnerability Checker Extension is installed.");
  });
  
  // Function to check security headers
  async function checkSecurityHeaders(url) {
    const response = await fetch(url);
    const headers = response.headers;
  
    let vulnerabilities = [];
  
    // List of important headers to check
    const importantHeaders = ['X-Frame-Options', 'Content-Security-Policy', 'Strict-Transport-Security', 'X-XSS-Protection'];
  
    // Check if critical headers are present
    importantHeaders.forEach(header => {
      if (!headers.get(header)) {
        vulnerabilities.push(`Missing ${header} header.`);
      }
    });
  
    return vulnerabilities;
  }
  
  // Function to check for open directories
  async function checkOpenDirectories(url) {
    const commonDirs = ['/admin/', '/backup/', '/test/', '/old/', '/config/'];
    let vulnerabilities = [];
  
    for (let dir of commonDirs) {
      try {
        const fullUrl = url + dir;
        const response = await fetch(fullUrl);
        if (response.status === 200) {
          vulnerabilities.push(`Open directory found: ${fullUrl}`);
        }
      } catch (error) {
        // Ignore errors if directory is not found
      }
    }
  
    return vulnerabilities;
  }
  
  // Function to test for SQL injection vulnerabilities
  async function testSQLInjection(url) {
    const testPayloads = ["' OR 1=1 --", '" OR "a"="a', "' OR 'a'='a"];
    let vulnerabilities = [];
  
    for (const payload of testPayloads) {
      try {
        const testUrl = `${url}?id=${encodeURIComponent(payload)}`;
        const response = await fetch(testUrl);
        if (response.text().includes('syntax error') || response.text().includes('mysql')) {
          vulnerabilities.push(`Possible SQL Injection vulnerability detected at: ${testUrl}`);
        }
      } catch (error) {
        // Ignore errors
      }
    }
  
    return vulnerabilities;
  }
  
  // Function to test for XSS vulnerabilities
  async function testXSS(url) {
    const payload = "<script>alert('XSS')</script>";
    let vulnerabilities = [];
  
    try {
      const testUrl = `${url}?search=${encodeURIComponent(payload)}`;
      const response = await fetch(testUrl);
      if (response.text().includes(payload)) {
        vulnerabilities.push(`Possible XSS vulnerability detected at: ${testUrl}`);
      }
    } catch (error) {
      // Ignore errors
    }
  
    return vulnerabilities;
  }
  
  // Main function to check website vulnerabilities
  async function checkWebsite(url) {
    let vulnerabilities = [];
  
    vulnerabilities = [
      ...await checkSecurityHeaders(url),
      ...await checkOpenDirectories(url),
      ...await testSQLInjection(url),
      ...await testXSS(url)
    ];
  
    return vulnerabilities;
  }
  
  // Listen for messages from content.js to start the check
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'check_website') {
      checkWebsite(message.url).then(vulnerabilities => {
        sendResponse(vulnerabilities);
      });
      return true;  // Keeps the message channel open for async response
    }
  });
  